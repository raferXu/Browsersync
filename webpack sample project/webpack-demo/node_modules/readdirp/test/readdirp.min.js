var test=require("tap").test,path=require("path"),fs=require("fs"),util=require("util"),net=require("net"),readdirp=require("../readdirp.js"),root=path.join(__dirname,"../test/bed"),totalDirs=6,totalFiles=12,ext1Files=4,ext2Files=3,ext3Files=2,rootDir2Files=2,nameHasLength9Dirs=2,depth1Files=8,depth0Files=3;function opts(c){var a={root:root};if(c){for(var b in c){a[b]=c[b]}}return a}test("\nreading root without filter",function(a){a.plan(2);readdirp(opts(),function(c,b){a.equals(b.directories.length,totalDirs,"all directories");a.equals(b.files.length,totalFiles,"all files");a.end()})});test("\nreading root without filter using lstat",function(a){a.plan(2);readdirp(opts({lstat:true}),function(c,b){a.equals(b.directories.length,totalDirs,"all directories");a.equals(b.files.length,totalFiles,"all files");a.end()})});test("\nreading root with symlinks using lstat",function(a){a.plan(2);fs.symlinkSync(path.join(root,"root_dir1"),path.join(root,"dirlink"));fs.symlinkSync(path.join(root,"root_file1.ext1"),path.join(root,"link.ext1"));readdirp(opts({lstat:true}),function(c,b){a.equals(b.directories.length,totalDirs,"all directories");a.equals(b.files.length,totalFiles+2,"all files + symlinks");fs.unlinkSync(path.join(root,"dirlink"));fs.unlinkSync(path.join(root,"link.ext1"));a.end()})});test("\nreading non-standard fds",function(a){a.plan(2);var b=net.createServer().listen(path.join(root,"test.sock"),function(){readdirp(opts({entryType:"all"}),function(d,c){a.equals(c.files.length,totalFiles+1,"all files + socket");readdirp(opts({entryType:"both"}),function(f,e){a.equals(e.files.length,totalFiles,"all regular files only");b.close();a.end()})})})});test("\nreading root using glob filter",function(a){a.test('\n# "*.ext1"',function(b){b.plan(1);readdirp(opts({fileFilter:"*.ext1"}),function(d,c){b.equals(c.files.length,ext1Files,"all ext1 files");b.end()})});a.test('\n# ["*.ext1", "*.ext3"]',function(b){b.plan(1);readdirp(opts({fileFilter:["*.ext1","*.ext3"]}),function(d,c){b.equals(c.files.length,ext1Files+ext3Files,"all ext1 and ext3 files");b.end()})});a.test('\n# "root_dir1"',function(b){b.plan(1);readdirp(opts({directoryFilter:"root_dir1"}),function(d,c){b.equals(c.directories.length,1,"one directory");b.end()})});a.test('\n# ["root_dir1", "*dir1_subdir1"]',function(b){b.plan(1);readdirp(opts({directoryFilter:["root_dir1","*dir1_subdir1"]}),function(d,c){b.equals(c.directories.length,2,"two directories");b.end()})});a.test('\n# negated: "!*.ext1"',function(b){b.plan(1);readdirp(opts({fileFilter:"!*.ext1"}),function(d,c){b.equals(c.files.length,totalFiles-ext1Files,"all but ext1 files");b.end()})});a.test('\n# negated: ["!*.ext1", "!*.ext3"]',function(b){b.plan(1);readdirp(opts({fileFilter:["!*.ext1","!*.ext3"]}),function(d,c){b.equals(c.files.length,totalFiles-ext1Files-ext3Files,"all but ext1 and ext3 files");b.end()})});a.test('\n# mixed: ["*.ext1", "!*.ext3"]',function(b){b.plan(1);readdirp(opts({fileFilter:["*.ext1","!*.ext3"]}),function(d,c){b.similar(d[0].toString(),/Cannot mix negated with non negated glob filters/,"returns meaningfull error");b.end()})});a.test('\n# leading and trailing spaces: [" *.ext1", "*.ext3 "]',function(b){b.plan(1);readdirp(opts({fileFilter:[" *.ext1","*.ext3 "]}),function(d,c){b.equals(c.files.length,ext1Files+ext3Files,"all ext1 and ext3 files");b.end()})});a.test('\n# leading and trailing spaces: [" !*.ext1", " !*.ext3 "]',function(b){b.plan(1);readdirp(opts({fileFilter:[" !*.ext1"," !*.ext3"]}),function(d,c){b.equals(c.files.length,totalFiles-ext1Files-ext3Files,"all but ext1 and ext3 files");b.end()})});a.test("\n# ** glob pattern",function(b){b.plan(1);readdirp(opts({fileFilter:"**/*.ext1"}),function(d,c){b.equals(c.files.length,ext1Files,"ignores ** in **/*.ext1 -> only *.ext1 files");b.end()})})});test("\n\nreading root using function filter",function(a){a.test('\n# file filter -> "contains root_dir2"',function(b){b.plan(1);readdirp(opts({fileFilter:function(c){return c.name.indexOf("root_dir2")>=0}}),function(d,c){b.equals(c.files.length,rootDir2Files,"all rootDir2Files");b.end()})});a.test('\n# directory filter -> "name has length 9"',function(b){b.plan(1);readdirp(opts({directoryFilter:function(c){return c.name.length===9}}),function(d,c){b.equals(c.directories.length,nameHasLength9Dirs,"all all dirs with name length 9");b.end()})})});test("\nreading root specifying maximum depth",function(a){a.test("\n# depth 1",function(b){b.plan(1);readdirp(opts({depth:1}),function(d,c){b.equals(c.files.length,depth1Files,"does not return files at depth 2")})})});test("\nreading root with no recursion",function(a){a.test("\n# depth 0",function(b){b.plan(1);readdirp(opts({depth:0}),function(d,c){b.equals(c.files.length,depth0Files,"does not return files at depth 0")})})});test("\nprogress callbacks",function(c){c.plan(2);var b=function(d){return d.name},a=[];readdirp(opts(),function(d){a.push(d)},function(e,d){c.equals(a.length,d.files.length,"calls back for each file processed");c.deepEquals(a.map(b).sort(),d.files.map(b).sort(),"same file names");c.end()})});test("resolving of name, full and relative paths",function(a){var c={name:"root_dir1_file1.ext1",parentDirName:"root_dir1",path:"root_dir1/root_dir1_file1.ext1",fullPath:"test/bed/root_dir1/root_dir1_file1.ext1"},b=[{root:"./bed",prefix:""},{root:"./bed/",prefix:""},{root:"bed",prefix:""},{root:"bed/",prefix:""},{root:"../test/bed/",prefix:""},{root:".",prefix:"bed"}];a.plan(b.length);b.forEach(function(d){d.fileFilter="root_dir1_file1.ext1";a.test("\n"+util.inspect(d),function(e){e.plan(4);readdirp(d,function(g,f){e.equals(f.files[0].name,c.name,"correct name");e.equals(f.files[0].path,path.join(d.prefix,c.path),"correct path")});fs.realpath(d.root,function(f,g){readdirp(d,function(i,h){e.equals(h.files[0].fullParentDir,path.join(g,d.prefix,c.parentDirName),"correct parentDir");e.equals(h.files[0].fullPath,path.join(g,d.prefix,c.parentDirName,c.name),"correct fullPath")})})})})});