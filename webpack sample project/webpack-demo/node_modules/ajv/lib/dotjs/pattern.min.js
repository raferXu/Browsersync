"use strict";module.exports=function generate_pattern(l,c,d){var k=" ";var j=l.level;var o=l.dataLevel;var p=l.schema[c];var e=l.schemaPath+l.util.getProperty(c);var b=l.errSchemaPath+"/"+c;var f=!l.opts.allErrors;var i="data"+(o||"");var m=l.opts.$data&&p&&p.$data,n;if(m){k+=" var schema"+(j)+" = "+(l.util.getData(p.$data,o,l.dataPathArr))+"; ";n="schema"+j}else{n=p}var g=m?"(new RegExp("+n+"))":l.usePattern(p);k+="if ( ";if(m){k+=" ("+(n)+" !== undefined && typeof "+(n)+" != 'string') || "}k+=" !"+(g)+".test("+(i)+") ) {   ";var a=a||[];a.push(k);k="";if(l.createErrors!==false){k+=" { keyword: '"+("pattern")+"' , dataPath: (dataPath || '') + "+(l.errorPath)+" , schemaPath: "+(l.util.toQuotedString(b))+" , params: { pattern:  ";if(m){k+=""+(n)}else{k+=""+(l.util.toQuotedString(p))}k+="  } ";if(l.opts.messages!==false){k+=" , message: 'should match pattern \"";if(m){k+="' + "+(n)+" + '"}else{k+=""+(l.util.escapeQuotes(p))}k+="\"' "}if(l.opts.verbose){k+=" , schema:  ";if(m){k+="validate.schema"+(e)}else{k+=""+(l.util.toQuotedString(p))}k+="         , parentSchema: validate.schema"+(l.schemaPath)+" , data: "+(i)+" "}k+=" } "}else{k+=" {} "}var h=k;k=a.pop();if(!l.compositeRule&&f){if(l.async){k+=" throw new ValidationError(["+(h)+"]); "}else{k+=" validate.errors = ["+(h)+"]; return false; "}}else{k+=" var err = "+(h)+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}k+="} ";if(f){k+=" else { "}return k};