"use strict";var curve=require("../curve");var BN=require("bn.js");var inherits=require("inherits");var Base=curve.base;var elliptic=require("../../elliptic");var utils=elliptic.utils;function MontCurve(a){Base.call(this,"mont",a);this.a=new BN(a.a,16).toRed(this.red);this.b=new BN(a.b,16).toRed(this.red);this.i4=new BN(4).toRed(this.red).redInvm();this.two=new BN(2).toRed(this.red);this.a24=this.i4.redMul(this.a.redAdd(this.two))}inherits(MontCurve,Base);module.exports=MontCurve;MontCurve.prototype.validate=function validate(b){var a=b.normalize().x;var c=a.redSqr();var e=c.redMul(a).redAdd(c.redMul(this.a)).redAdd(a);var d=e.redSqrt();return d.redSqr().cmp(e)===0};function Point(c,a,b){Base.BasePoint.call(this,c,"projective");if(a===null&&b===null){this.x=this.curve.one;this.z=this.curve.zero}else{this.x=new BN(a,16);this.z=new BN(b,16);if(!this.x.red){this.x=this.x.toRed(this.curve.red)}if(!this.z.red){this.z=this.z.toRed(this.curve.red)}}}inherits(Point,Base.BasePoint);MontCurve.prototype.decodePoint=function decodePoint(a,b){return this.point(utils.toArray(a,b),1)};MontCurve.prototype.point=function point(a,b){return new Point(this,a,b)};MontCurve.prototype.pointFromJSON=function pointFromJSON(a){return Point.fromJSON(this,a)};Point.prototype.precompute=function precompute(){};Point.prototype._encode=function _encode(){return this.getX().toArray("be",this.curve.p.byteLength())};Point.fromJSON=function fromJSON(b,a){return new Point(b,a[0],a[1]||b.one)};Point.prototype.inspect=function inspect(){if(this.isInfinity()){return"<EC Point Infinity>"}return"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"};Point.prototype.isInfinity=function isInfinity(){return this.z.cmpn(0)===0};Point.prototype.dbl=function dbl(){var f=this.x.redAdd(this.z);var g=f.redSqr();var e=this.x.redSub(this.z);var i=e.redSqr();var j=g.redSub(i);var d=g.redMul(i);var h=j.redMul(i.redAdd(this.curve.a24.redMul(j)));return this.curve.point(d,h)};Point.prototype.add=function add(){throw new Error("Not supported on Montgomery curve")};Point.prototype.diffAdd=function diffAdd(e,m){var l=this.x.redAdd(this.z);var k=this.x.redSub(this.z);var j=e.x.redAdd(e.z);var i=e.x.redSub(e.z);var n=i.redMul(l);var f=j.redMul(k);var h=m.z.redMul(n.redAdd(f).redSqr());var g=m.x.redMul(n.redISub(f).redSqr());return this.curve.point(h,g)};Point.prototype.mul=function mul(f){var h=f.clone();var e=this;var d=this.curve.point(null,null);var l=this;for(var j=[];h.cmpn(0)!==0;h.iushrn(1)){j.push(h.andln(1))}for(var g=j.length-1;g>=0;g--){if(j[g]===0){e=e.diffAdd(d,l);d=d.dbl()}else{d=e.diffAdd(d,l);e=e.dbl()}}return d};Point.prototype.mulAdd=function mulAdd(){throw new Error("Not supported on Montgomery curve")};Point.prototype.jumlAdd=function jumlAdd(){throw new Error("Not supported on Montgomery curve")};Point.prototype.eq=function eq(a){return this.getX().cmp(a.getX())===0};Point.prototype.normalize=function normalize(){this.x=this.x.redMul(this.z.redInvm());this.z=this.curve.one;return this};Point.prototype.getX=function getX(){this.normalize();return this.x.fromRed()};