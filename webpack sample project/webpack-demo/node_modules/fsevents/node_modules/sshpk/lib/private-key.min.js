module.exports=PrivateKey;var assert=require("assert-plus");var algs=require("./algs");var crypto=require("crypto");var Fingerprint=require("./fingerprint");var Signature=require("./signature");var errs=require("./errors");var util=require("util");var utils=require("./utils");var dhe=require("./dhe");var generateECDSA=dhe.generateECDSA;var generateED25519=dhe.generateED25519;var edCompat;var ed;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key");var InvalidAlgorithmError=errs.InvalidAlgorithmError;var KeyParseError=errs.KeyParseError;var KeyEncryptedError=errs.KeyEncryptedError;var formats={};formats.auto=require("./formats/auto");formats.pem=require("./formats/pem");formats.pkcs1=require("./formats/pkcs1");formats.pkcs8=require("./formats/pkcs8");formats.rfc4253=require("./formats/rfc4253");formats["ssh-private"]=require("./formats/ssh-private");formats.openssh=formats["ssh-private"];formats.ssh=formats["ssh-private"];function PrivateKey(a){assert.object(a,"options");Key.call(this,a);this._pubCache=undefined}util.inherits(PrivateKey,Key);PrivateKey.formats=formats;PrivateKey.prototype.toBuffer=function(b,a){if(b===undefined){b="pkcs1"}assert.string(b,"format");assert.object(formats[b],"formats[format]");assert.optionalObject(a,"options");return(formats[b].write(this,a))};PrivateKey.prototype.hash=function(a){return(this.toPublic().hash(a))};PrivateKey.prototype.toPublic=function(){if(this._pubCache){return(this._pubCache)}var d=algs.info[this.type];var c=[];for(var a=0;a<d.parts.length;++a){var b=d.parts[a];c.push(this.part[b])}this._pubCache=new Key({type:this.type,source:this,parts:c});if(this.comment){this._pubCache.comment=this.comment}return(this._pubCache)};PrivateKey.prototype.derive=function(c,a){assert.string(c,"type");assert.optionalNumber(a,"size");var b,d;if(this.type==="ed25519"&&c==="curve25519"){if(ed===undefined){ed=require("jodid25519")}b=this.part.r.data;if(b[0]===0){b=b.slice(1)}b=b.slice(0,32);d=ed.dh.publicKey(b);b=utils.mpNormalize(Buffer.concat([b,d]));return(new PrivateKey({type:"curve25519",parts:[{name:"R",data:utils.mpNormalize(d)},{name:"r",data:b}]}))}else{if(this.type==="curve25519"&&c==="ed25519"){if(ed===undefined){ed=require("jodid25519")}b=this.part.r.data;if(b[0]===0){b=b.slice(1)}b=b.slice(0,32);d=ed.eddsa.publicKey(b.toString("binary"));d=new Buffer(d,"binary");b=utils.mpNormalize(Buffer.concat([b,d]));return(new PrivateKey({type:"ed25519",parts:[{name:"R",data:utils.mpNormalize(d)},{name:"r",data:b}]}))}}throw (new Error("Key derivation not supported from "+this.type+" to "+c))};PrivateKey.prototype.createVerify=function(a){return(this.toPublic().createVerify(a))};PrivateKey.prototype.createSign=function(a){if(a===undefined){a=this.defaultHashAlgorithm()}assert.string(a,"hash algorithm");if(this.type==="ed25519"&&edCompat!==undefined){return(new edCompat.Signer(this,a))}if(this.type==="curve25519"){throw (new Error("Curve25519 keys are not suitable for signing or verification"))}var i,j,d;try{j=a.toUpperCase();i=crypto.createSign(j)}catch(f){d=f}if(i===undefined||(d instanceof Error&&d.message.match(/Unknown message digest/))){j="RSA-";j+=a.toUpperCase();i=crypto.createSign(j)}assert.ok(i,"failed to create verifier");var c=i.sign.bind(i);var h=this.toBuffer("pkcs1");var g=this.type;var b=this.curve;i.sign=function(){var k=c(h);if(typeof(k)==="string"){k=new Buffer(k,"binary")}k=Signature.parse(k,g,"asn1");k.hashAlgorithm=a;k.curve=b;return(k)};return(i)};PrivateKey.parse=function(c,f,b){if(typeof(c)!=="string"){assert.buffer(c,"data")}if(f===undefined){f="auto"}assert.string(f,"format");if(typeof(b)==="string"){b={filename:b}}assert.optionalObject(b,"options");if(b===undefined){b={}}assert.optionalString(b.filename,"options.filename");if(b.filename===undefined){b.filename="(unnamed)"}assert.object(formats[f],"formats[format]");try{var a=formats[f].read(c,b);assert.ok(a instanceof PrivateKey,"key is not a private key");if(!a.comment){a.comment=b.filename}return(a)}catch(d){if(d.name==="KeyEncryptedError"){throw (d)}throw (new KeyParseError(b.filename,f,d))}};PrivateKey.isPrivateKey=function(b,a){return(utils.isCompatible(b,PrivateKey,a))};PrivateKey.generate=function(b,a){if(a===undefined){a={}}assert.object(a,"options");switch(b){case"ecdsa":if(a.curve===undefined){a.curve="nistp256"}assert.string(a.curve,"options.curve");return(generateECDSA(a.curve));case"ed25519":return(generateED25519());default:throw (new Error('Key generation not supported with key type "'+b+'"'))}};PrivateKey.prototype._sshpkApiVersion=[1,4];PrivateKey._oldVersionDetect=function(a){assert.func(a.toPublic);assert.func(a.createSign);if(a.derive){return([1,3])}if(a.defaultHashAlgorithm){return([1,2])}if(a.formats.auto){return([1,1])}return([1,0])};