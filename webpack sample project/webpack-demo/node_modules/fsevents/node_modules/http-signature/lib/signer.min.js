var assert=require("assert-plus");var crypto=require("crypto");var http=require("http");var util=require("util");var sshpk=require("sshpk");var jsprim=require("jsprim");var utils=require("./utils");var sprintf=require("util").format;var HASH_ALGOS=utils.HASH_ALGOS;var PK_ALGOS=utils.PK_ALGOS;var InvalidAlgorithmError=utils.InvalidAlgorithmError;var HttpSignatureError=utils.HttpSignatureError;var validateAlgorithm=utils.validateAlgorithm;var AUTHZ_FMT='Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';function MissingHeaderError(a){HttpSignatureError.call(this,a,MissingHeaderError)}util.inherits(MissingHeaderError,HttpSignatureError);function StrictParsingError(a){HttpSignatureError.call(this,a,StrictParsingError)}util.inherits(StrictParsingError,HttpSignatureError);function RequestSigner(a){assert.object(a,"options");var c=[];if(a.algorithm!==undefined){assert.string(a.algorithm,"options.algorithm");c=validateAlgorithm(a.algorithm)}this.rs_alg=c;if(a.sign!==undefined){assert.func(a.sign,"options.sign");this.rs_signFunc=a.sign}else{if(c[0]==="hmac"&&a.key!==undefined){assert.string(a.keyId,"options.keyId");this.rs_keyId=a.keyId;if(typeof(a.key)!=="string"&&!Buffer.isBuffer(a.key)){throw (new TypeError("options.key for HMAC must be a string or Buffer"))}this.rs_signer=crypto.createHmac(c[1].toUpperCase(),a.key);this.rs_signer.sign=function(){var d=this.digest("base64");return({hashAlgorithm:c[1],toString:function(){return(d)}})}}else{if(a.key!==undefined){var b=a.key;if(typeof(b)==="string"||Buffer.isBuffer(b)){b=sshpk.parsePrivateKey(b)}assert.ok(sshpk.PrivateKey.isPrivateKey(b,[1,2]),"options.key must be a sshpk.PrivateKey");this.rs_key=b;assert.string(a.keyId,"options.keyId");this.rs_keyId=a.keyId;if(!PK_ALGOS[b.type]){throw (new InvalidAlgorithmError(b.type.toUpperCase()+" type keys are not supported"))}if(c[0]!==undefined&&b.type!==c[0]){throw (new InvalidAlgorithmError("options.key must be a "+c[0].toUpperCase()+" key, was given a "+b.type.toUpperCase()+" key instead"))}this.rs_signer=b.createSign(c[1])}else{throw (new TypeError("options.sign (func) or options.key is required"))}}}this.rs_headers=[];this.rs_lines=[]}RequestSigner.prototype.writeHeader=function(c,b){assert.string(c,"header");c=c.toLowerCase();assert.string(b,"value");this.rs_headers.push(c);if(this.rs_signFunc){this.rs_lines.push(c+": "+b)}else{var a=c+": "+b;if(this.rs_headers.length>0){a="\n"+a}this.rs_signer.update(a)}return(b)};RequestSigner.prototype.writeDateHeader=function(){return(this.writeHeader("date",jsprim.rfc1123(new Date())))};RequestSigner.prototype.writeTarget=function(b,a){assert.string(b,"method");assert.string(a,"path");b=b.toLowerCase();this.writeHeader("(request-target)",b+" "+a)};RequestSigner.prototype.sign=function(a){assert.func(a,"callback");if(this.rs_headers.length<1){throw (new Error("At least one header must be signed"))}var i,f;if(this.rs_signFunc){var g=this.rs_lines.join("\n");var c=this;this.rs_signFunc(g,function(j,l){if(j){a(j);return}try{assert.object(l,"signature");assert.string(l.keyId,"signature.keyId");assert.string(l.algorithm,"signature.algorithm");assert.string(l.signature,"signature.signature");i=validateAlgorithm(l.algorithm);f=sprintf(AUTHZ_FMT,l.keyId,l.algorithm,c.rs_headers.join(" "),l.signature)}catch(k){a(k);return}a(null,f)})}else{try{var d=this.rs_signer.sign()}catch(h){a(h);return}i=(this.rs_alg[0]||this.rs_key.type)+"-"+d.hashAlgorithm;var b=d.toString();f=sprintf(AUTHZ_FMT,this.rs_keyId,i,this.rs_headers.join(" "),b);a(null,f)}};module.exports={isSigner:function(a){if(typeof(a)==="object"&&a instanceof RequestSigner){return(true)}return(false)},createSigner:function createSigner(a){return(new RequestSigner(a))},signRequest:function signRequest(d,n){assert.object(d,"request");assert.object(n,"options");assert.optionalString(n.algorithm,"options.algorithm");assert.string(n.keyId,"options.keyId");assert.optionalArrayOfString(n.headers,"options.headers");assert.optionalString(n.httpVersion,"options.httpVersion");if(!d.getHeader("Date")){d.setHeader("Date",jsprim.rfc1123(new Date()))}if(!n.headers){n.headers=["date"]}if(!n.httpVersion){n.httpVersion="1.1"}var a=[];if(n.algorithm){n.algorithm=n.algorithm.toLowerCase();a=validateAlgorithm(n.algorithm)}var e;var j="";for(e=0;e<n.headers.length;e++){if(typeof(n.headers[e])!=="string"){throw new TypeError("options.headers must be an array of Strings")}var f=n.headers[e].toLowerCase();if(f==="request-line"){if(!n.strict){j+=d.method+" "+d.path+" HTTP/"+n.httpVersion}else{throw (new StrictParsingError("request-line is not a valid header with strict parsing enabled."))}}else{if(f==="(request-target)"){j+="(request-target): "+d.method.toLowerCase()+" "+d.path}else{var l=d.getHeader(f);if(l===undefined||l===""){throw new MissingHeaderError(f+" was not in the request")}j+=f+": "+l}}if((e+1)<n.headers.length){j+="\n"}}if(d.hasOwnProperty("_stringToSign")){d._stringToSign=j}var c;if(a[0]==="hmac"){if(typeof(n.key)!=="string"&&!Buffer.isBuffer(n.key)){throw (new TypeError("options.key must be a string or Buffer"))}var g=crypto.createHmac(a[1].toUpperCase(),n.key);g.update(j);c=g.digest("base64")}else{var m=n.key;if(typeof(m)==="string"||Buffer.isBuffer(m)){m=sshpk.parsePrivateKey(n.key)}assert.ok(sshpk.PrivateKey.isPrivateKey(m,[1,2]),"options.key must be a sshpk.PrivateKey");if(!PK_ALGOS[m.type]){throw (new InvalidAlgorithmError(m.type.toUpperCase()+" type keys are not supported"))}if(a[0]!==undefined&&m.type!==a[0]){throw (new InvalidAlgorithmError("options.key must be a "+a[0].toUpperCase()+" key, was given a "+m.type.toUpperCase()+" key instead"))}var b=m.createSign(a[1]);b.update(j);var k=b.sign();if(!HASH_ALGOS[k.hashAlgorithm]){throw (new InvalidAlgorithmError(k.hashAlgorithm.toUpperCase()+" is not a supported hash algorithm"))}n.algorithm=m.type+"-"+k.hashAlgorithm;c=k.toString();assert.notStrictEqual(c,"","empty signature produced")}d.setHeader("Authorization",sprintf(AUTHZ_FMT,n.keyId,n.algorithm,n.headers.join(" "),c));return true}};